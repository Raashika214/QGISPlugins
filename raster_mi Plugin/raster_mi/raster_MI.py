# -*- coding: utf-8 -*-
"""
/***************************************************************************
 rasterMI
                                 A QGIS plugin
 This plugin is for raster data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-28
        git sha              : $Format:%H$
        copyright            : (C) 2022 by edula raashika
        email                : edularaashika@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QRectF
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .raster_MI_dialog import rasterMIDialog
import os.path

import csv
import matplotlib.pyplot as plt

from PyQt5.QtWidgets import QAction,QFileDialog
from qgis.gui import QgsMapToolEmitPoint,QgsMapToolPan,QgsMapCanvas,QgsMapCanvasItem
from qgis.core import QgsPointXY,QgsProject, QgsPoint, QgsVector, QgsAnnotationLayer, QgsAnnotationPointTextItem, QgsAnnotationMarkerItem
from osgeo import gdal
from pathlib import Path

class rasterMI:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'rasterMI_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&rasterMI')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        self.xyNote = []
        self.xPoint = []
        self.yPoint = []
        self.currentIndex = 0
        self.bandCount = 0
        self.metaData = ""
        self.xticks = []
        self.canvas = self.iface.mapCanvas()
        self.pointTool = QgsMapToolEmitPoint(self.canvas)
        self.pointTool.canvasClicked.connect(self.displayPoint)
        self.notelayer = QgsAnnotationLayer(name="Annotations", options=QgsAnnotationLayer.LayerOptions(
            QgsProject.instance().transformContext()))

        self.mapTool = QgsMapToolPan(self.canvas)
        self.layer = self.canvas.currentLayer()
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('rasterMI', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/raster_MI/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&rasterMI'),
                action)
            self.canvas.setMapTool(self.mapTool)
            self.iface.removeToolBarIcon(action)

    # set the filepath and name to save pixels
    def saveFilePath(self):

        # get the file name to save
        saveFilename, _filter = QFileDialog.getSaveFileName(self.dlg, "Select folder to save", "", '*.csv')
        self.dlg.SaveFileLine.setText(saveFilename)
        self.filename = self.dlg.SaveFileLine.text()

    # saving the selected points to the given file
    def saveToFile(self):
        # creating file to save pixels
        self.fileEdit = open(self.filename, 'w+', newline='', encoding='utf-8')
        self.Index = 0
        for i in range(len(self.xPoint)):
            self.writeLine = str(self.xPoint[self.Index])+','+str(self.yPoint[self.Index]) + ',' + str(self.xyNote[self.Index])
            bandData = self.getMiBandData(self.xPoint[self.Index],self.yPoint[self.Index])
            bandValues = ",".join(str(bandValue) for bandValue in bandData[1:])
            self.writeLine  += ',' + bandValues
            self.Index += 1
            self.fileEdit.write(self.writeLine+'\n')
        self.fileEdit.close()
        self.push_message("File Saved")

    # update lists after selecting new pixel
    def displayPoint(self,pointTool):
        self.currentIndex = len(self.xPoint)
        self.xPoint.append(pointTool[0])
        self.yPoint.append(pointTool[1])
        self.xyNote.append('Note: '+ str(self.dlg.XYNoteBox.toPlainText()))
        self.dlg.XYNoteBox.setPlainText("")
        self.combo_populate()
        self.spectraLineGraph()
        self.pixelAnnotationMark()
        self.currentIndex += 1

    # update combo box each time after selecting pixel
    def combo_populate(self):
        self.Index = 0
        self.dlg.XYCombo.clear()
        for index in range(len(self.xPoint)):
            self.dlg.XYCombo.addItem(
            "Pixel" + str(self.Index + 1) + " X: " + str(self.xPoint[self.Index]) + " Y: " + str(
                self.yPoint[self.Index]))
            self.Index +=1


    # line plot of the selected pixel
    def spectraLineGraph(self):
        x_coordinate = self.xPoint[self.currentIndex]
        y_coordinate = self.yPoint[self.currentIndex]
        band_data = self.getMiBandData(x_coordinate,y_coordinate)
        plt.close()
        plt.ion()
        plt.plot(self.bands, band_data)
        plt.xticks(self.bands,self.xticks )
        plt.xlabel("Wavelength (nm)")
        plt.show()

    # get band data of the selected point
    def getMiBandData(self,x_coordinate,y_coordinate):
        self.setMiLayer()
        layer = self.iface.activeLayer()
        self.iface.setActiveLayer(layer)
        data = []
        for i in range(self.bandCount+1):
            val, res =  layer.dataProvider().sample(QgsPointXY(x_coordinate,y_coordinate),i)
            data.append(val)
        self.bands = [*range(0, self.bandCount+1, 1)]
        return data

    # set MI layer as current layer
    def setMiLayer(self):
        layers_names = []
        for layer in QgsProject.instance().mapLayers().values():
            layers_names.append(layer.name())


        for layer in layers_names:
            if layer[:2] != 'An':
                layer = QgsProject.instance().mapLayersByName(layer)[0]
                self.iface.setActiveLayer(layer)
                self.bandCount = self.iface.activeLayer().bandCount()
                break

    # mark selected points on the layer along with notes
    def pixelAnnotationMark(self):
        layer_names = []
        for layer in QgsProject.instance().mapLayers().values():
            layer_names.append(layer.name())
        if 'Annotations' not in layer_names:
            QgsProject.instance().addMapLayer(self.notelayer)
        else:
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('Annotations')[0])
            self.notelayer = QgsAnnotationLayer(name="Annotations", options=QgsAnnotationLayer.LayerOptions(
                QgsProject.instance().transformContext()))
            QgsProject.instance().addMapLayer(self.notelayer)

        self.notelayer.clear()

        for i in range(len(self.xPoint)):

            annotation = QgsAnnotationPointTextItem(self.xyNote[i],QgsPointXY(self.xPoint[i],self.yPoint[i]))
            annotation_marker = QgsAnnotationMarkerItem(QgsPoint(self.xPoint[i],self.yPoint[i]))

            self.notelayer.addItem(annotation)
            self.notelayer.addItem(annotation_marker)
        self.push_message("Map Updated")

    # delete selected pixels
    def deletePixel(self):
        # delete range of pixels
        if self.dlg.deletePixelLine1.text() != "":
            index = int(self.dlg.deletePixelLine1.text()) - 1
            end = int(self.dlg.deletePixelLine2.text())
            for i in range(end - index):
                self.dlg.XYCombo.removeItem(index)
                del self.xPoint[index]
                del self.yPoint[index]
                del self.xyNote[index]
            self.pixelAnnotationMark()

        # delete current pixel in comboBox
        else :
            index = self.dlg.XYCombo.currentIndex()
            self.dlg.XYCombo.removeItem(index)
            del self.xPoint[index]
            del self.yPoint[index]
            del self.xyNote[index]
            self.pixelAnnotationMark()

    def push_message(self,message):
        self.iface.messageBar().pushMessage(message)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = rasterMIDialog()


        # set mi layer
        self.setMiLayer()
        layer = self.iface.activeLayer()
        self.iface.setActiveLayer(layer)
        path = str(layer.source())

        # get meta data of the MI or SP kaguya data for plotting wavelengths
        if Path(path).suffix == '.img':
            metadata = gdal.Open(path).GetMetadata()
            self.xticks = list(metadata.values())[:-1]

        else:
            metadata = gdal.Open(path).GetMetadata()
            wavelengthValues = metadata.get('CENTER_FILTER_WAVELENGTH')[1:-1].replace("<nm>", "").split(',')
            self.xticks = [float(wavelength) for wavelength in wavelengthValues]
            self.xticks.insert(0, 0)

        # show the dialog
        self.dlg.show()
        # to set point tool
        self.canvas.setMapTool(self.pointTool)
        # to display file dialog when browser button is selected
        self.dlg.SaveFileSelect.clicked.connect(lambda: self.saveFilePath())
        # save pixels to the selected file path
        self.dlg.SaveFileButton.clicked.connect(lambda:self.saveToFile())
        # connect  to delete pixel function when delete pixel button is clicked
        self.dlg.deletePixelButton.clicked.connect(lambda:self.deletePixel())
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass